<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Flap</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #0f172a; 
            font-family: 'Space Grotesk', sans-serif;
            touch-action: none; /* Prevent zoom/scroll on mobile */
        }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%;
        }
        .glass-panel {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body class="h-screen w-screen relative text-white select-none">

    <!-- Canvas Layer -->
    <canvas id="gameCanvas" class="absolute inset-0 z-0"></canvas>

    <!-- UI Layer -->
    <div id="ui-layer" class="absolute inset-0 z-10 flex flex-col items-center justify-center pointer-events-none">
        
        <!-- HUD (Heads Up Display) -->
        <div class="absolute top-6 left-6 right-6 flex justify-between items-start pointer-events-none">
            <div class="glass-panel rounded-2xl px-4 py-2">
                <span class="text-gray-400 text-xs uppercase tracking-widest">Score</span>
                <div id="score-display" class="text-2xl font-bold text-cyan-400">0</div>
            </div>
            <div class="glass-panel rounded-2xl px-4 py-2 text-right">
                <span class="text-gray-400 text-xs uppercase tracking-widest">Best</span>
                <div id="best-score-display" class="text-2xl font-bold text-purple-400">0</div>
            </div>
        </div>

        <!-- Main Menu -->
        <div id="main-menu" class="text-center pointer-events-auto transition-all duration-500">
            <h1 class="text-7xl md:text-8xl font-bold text-transparent bg-clip-text bg-gradient-to-br from-cyan-400 via-blue-500 to-purple-600 mb-2 drop-shadow-[0_0_30px_rgba(6,182,212,0.3)]">NEON<br>FLAP</h1>
            <p class="text-blue-200/70 text-lg mb-8 tracking-widest uppercase">Avoid the obstacles</p>
            
            <button id="start-btn" class="group relative px-8 py-4 bg-cyan-500/10 hover:bg-cyan-500/20 border border-cyan-500/50 rounded-full text-cyan-300 font-bold tracking-widest transition-all hover:scale-105 hover:shadow-[0_0_30px_rgba(6,182,212,0.4)] cursor-pointer overflow-hidden">
                <span class="relative z-10">INITIALIZE</span>
                <div class="absolute inset-0 bg-cyan-500/20 transform scale-x-0 group-hover:scale-x-100 transition-transform origin-left duration-300"></div>
            </button>
            
            <p class="text-slate-500 mt-6 text-sm animate-pulse">Press Space or Tap Screen</p>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="hidden text-center pointer-events-auto transition-all duration-500 transform scale-90 opacity-0">
            <h2 class="text-6xl font-bold text-red-500 mb-2 drop-shadow-[0_0_20px_rgba(239,68,68,0.5)]">CRITICAL<br>FAILURE</h2>
            
            <div class="glass-panel p-6 rounded-2xl my-8 min-w-[200px] mx-auto border-red-500/20">
                <div class="mb-4">
                    <div class="text-gray-400 text-xs uppercase tracking-widest">Final Score</div>
                    <div id="final-score" class="text-4xl font-bold text-white">0</div>
                </div>
                <div class="w-full h-px bg-white/10 my-2"></div>
                 <div>
                    <div class="text-gray-400 text-xs uppercase tracking-widest">High Score</div>
                    <div id="final-best-score" class="text-xl font-bold text-purple-400">0</div>
                </div>
            </div>

            <button id="restart-btn" class="group relative px-8 py-4 bg-red-500/10 hover:bg-red-500/20 border border-red-500/50 rounded-full text-red-300 font-bold tracking-widest transition-all hover:scale-105 hover:shadow-[0_0_30px_rgba(239,68,68,0.4)] cursor-pointer overflow-hidden">
                <span class="relative z-10">RETRY SYSTEM</span>
                <div class="absolute inset-0 bg-red-500/20 transform scale-x-0 group-hover:scale-x-100 transition-transform origin-left duration-300"></div>
            </button>
        </div>
    </div>

    <script>
        // --- Game Constants & Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const uiLayer = document.getElementById('ui-layer');
        const mainMenu = document.getElementById('main-menu');
        const gameOverScreen = document.getElementById('game-over-screen');
        const scoreDisplay = document.getElementById('score-display');
        const bestScoreDisplay = document.getElementById('best-score-display');
        const finalScoreDisplay = document.getElementById('final-score');
        const finalBestScoreDisplay = document.getElementById('final-best-score');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');

        // Game State
        let frames = 0;
        let score = 0;
        let highScore = localStorage.getItem('neonFlapHighScore') || 0;
        let gameState = 'START'; // START, PLAYING, GAMEOVER
        let gameSpeed = 3;
        
        // Resize handling
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        bestScoreDisplay.innerText = highScore;

        // --- Classes ---

        class Particle {
            constructor(x, y, color, velocity) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = Math.random() * 3 + 1;
                this.velocity = velocity || {
                    x: (Math.random() - 0.5) * 5,
                    y: (Math.random() - 0.5) * 5
                };
                this.alpha = 1;
                this.decay = Math.random() * 0.03 + 0.01;
            }

            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= this.decay;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Bird {
            constructor() {
                this.radius = 12;
                this.x = canvas.width / 4;
                this.y = canvas.height / 2;
                this.velocity = 0;
                this.gravity = 0.4;
                this.jumpStrength = -7;
                this.rotation = 0;
                this.trail = [];
                this.glowColor = '#22d3ee'; // Cyan-400
            }

            jump() {
                this.velocity = this.jumpStrength;
                // Add jump particles
                for (let i = 0; i < 8; i++) {
                    particles.push(new Particle(this.x, this.y, this.glowColor, {
                        x: (Math.random() - 0.5) * 4,
                        y: (Math.random() * 4) + 2 
                    }));
                }
            }

            update() {
                this.velocity += this.gravity;
                this.y += this.velocity;
                
                // Rotation based on velocity
                this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity * 0.1)));

                // Trail effect
                if (frames % 2 === 0) {
                    this.trail.push({x: this.x, y: this.y, alpha: 0.8});
                }
                if (this.trail.length > 10) this.trail.shift();
                this.trail.forEach(t => t.alpha -= 0.05);

                // Floor Collision
                if (this.y + this.radius >= canvas.height) {
                    this.y = canvas.height - this.radius;
                    gameOver();
                }
                
                // Ceiling Collision (optional, keeping it playable)
                if (this.y - this.radius <= 0) {
                    this.y = this.radius;
                    this.velocity = 0;
                }
            }

            draw() {
                // Draw Trail
                this.trail.forEach((point, index) => {
                    const size = this.radius * (index / this.trail.length);
                    ctx.fillStyle = `rgba(34, 211, 238, ${point.alpha})`; // Cyan
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.glowColor;

                // Body
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Eye (for fun)
                ctx.fillStyle = '#0f172a';
                ctx.beginPath();
                ctx.arc(6, -4, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Pipe {
            constructor() {
                this.width = 60;
                this.gap = 190;
                this.x = canvas.width;
                this.topHeight = Math.random() * (canvas.height - this.gap - 100) + 50;
                this.bottomY = this.topHeight + this.gap;
                this.passed = false;
                
                // Random Neon Colors
                const colors = [
                    { main: '#3b82f6', dark: '#1e3a8a', light: '#60a5fa' }, // Blue
                    { main: '#a855f7', dark: '#581c87', light: '#c084fc' }, // Purple
                    { main: '#ec4899', dark: '#831843', light: '#f472b6' }, // Pink
                    { main: '#10b981', dark: '#064e3b', light: '#34d399' }, // Green
                    { main: '#f59e0b', dark: '#78350f', light: '#fbbf24' }  // Amber
                ];
                this.theme = colors[Math.floor(Math.random() * colors.length)];
            }

            update() {
                this.x -= gameSpeed;
            }

            draw() {
                // Recalculate bottom height in case of resize
                const currentBottomHeight = canvas.height - this.bottomY;

                ctx.shadowBlur = 15;
                ctx.shadowColor = this.theme.main;
                
                // Gradient fill
                const grad = ctx.createLinearGradient(this.x, 0, this.x + this.width, 0);
                grad.addColorStop(0, this.theme.dark); 
                grad.addColorStop(0.5, this.theme.main); 
                grad.addColorStop(1, this.theme.dark);

                // Top Pipe
                ctx.fillStyle = grad;
                ctx.fillRect(this.x, 0, this.width, this.topHeight);
                
                // Bottom Pipe
                ctx.fillStyle = grad;
                ctx.fillRect(this.x, this.bottomY, this.width, currentBottomHeight);

                // Neon Edges
                ctx.strokeStyle = this.theme.light;
                ctx.lineWidth = 2;
                
                // Top Cap
                ctx.strokeRect(this.x, 0, this.width, this.topHeight);
                ctx.fillStyle = this.theme.light;
                ctx.fillRect(this.x - 2, this.topHeight - 10, this.width + 4, 10);

                // Bottom Cap
                ctx.strokeRect(this.x, this.bottomY, this.width, currentBottomHeight);
                ctx.fillRect(this.x - 2, this.bottomY, this.width + 4, 10);

                ctx.shadowBlur = 0;
            }
        }

        class Background {
            constructor() {
                this.stars = [];
                for(let i=0; i<50; i++) {
                    this.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 2,
                        speed: Math.random() * 0.5 + 0.1
                    });
                }
            }

            update() {
                this.stars.forEach(star => {
                    star.x -= star.speed;
                    if(star.x < 0) {
                        star.x = canvas.width;
                        star.y = Math.random() * canvas.height;
                    }
                });
            }

            draw() {
                ctx.fillStyle = '#ffffff';
                this.stars.forEach(star => {
                    ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }
        }

        // --- Global Variables ---
        let bird;
        let pipes = [];
        let particles = [];
        let bg;
        let animationId;

        // --- Game Logic ---

        function init() {
            bird = new Bird();
            pipes = [];
            particles = [];
            bg = new Background();
            score = 0;
            gameSpeed = 3;
            frames = 0;
            scoreDisplay.innerText = score;
            bestScoreDisplay.innerText = highScore;
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            if (gameState !== 'GAMEOVER') bg.update();
            bg.draw();

            // Pipes
            if (gameState === 'PLAYING') {
                if (frames % 120 === 0) {
                    pipes.push(new Pipe());
                }
                if (frames % 500 === 0) {
                    gameSpeed += 0.2;
                }
            }

            pipes.forEach((pipe, index) => {
                if (gameState === 'PLAYING') pipe.update();
                pipe.draw();

                if (gameState === 'PLAYING') {
                    // Collision
                    if (
                        bird.x + bird.radius > pipe.x && 
                        bird.x - bird.radius < pipe.x + pipe.width && 
                        (bird.y - bird.radius < pipe.topHeight || bird.y + bird.radius > pipe.bottomY)
                    ) {
                        gameOver();
                    }

                    // Score
                    if (pipe.x + pipe.width < bird.x && !pipe.passed) {
                        score++;
                        scoreDisplay.innerText = score;
                        pipe.passed = true;
                        for (let i = 0; i < 10; i++) {
                             particles.push(new Particle(bird.x, bird.y - 20, '#facc15', null));
                        }
                    }
                }

                // Clean up pipes only if playing (keep them visible on death)
                if (gameState === 'PLAYING' && pipe.x + pipe.width < 0) {
                    pipes.splice(index, 1);
                }
            });

            // Bird
            if (gameState === 'PLAYING') {
                bird.update();
                bird.draw();
            } else if (gameState === 'START') {
                bird.y = canvas.height / 2 + Math.sin(frames * 0.05) * 10;
                bird.trail = [];
                bird.draw();
            } 
            // In GAMEOVER, we don't draw the bird (it exploded)

            // Particles (always animate)
            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.alpha <= 0) particles.splice(index, 1);
            });

            frames++;
            animationId = requestAnimationFrame(animate);
        }

        function startGame() {
            gameState = 'PLAYING';
            mainMenu.style.opacity = '0';
            mainMenu.style.pointerEvents = 'none';
            gameOverScreen.classList.add('hidden');
            init();
            bird.jump();
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            // Do not cancel animation frame, let it loop to show particles

            // Explosion particles
            for(let i=0; i<50; i++) {
                particles.push(new Particle(bird.x, bird.y, '#ef4444', {
                     x: (Math.random() - 0.5) * 15,
                     y: (Math.random() - 0.5) * 15
                }));
                particles.push(new Particle(bird.x, bird.y, '#ffffff', {
                     x: (Math.random() - 0.5) * 10,
                     y: (Math.random() - 0.5) * 10
                }));
            }

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('neonFlapHighScore', highScore);
            }
            
            finalScoreDisplay.innerText = score;
            finalBestScoreDisplay.innerText = highScore;

            gameOverScreen.classList.remove('hidden');
            setTimeout(() => {
                gameOverScreen.classList.remove('scale-90', 'opacity-0');
                gameOverScreen.classList.add('scale-100', 'opacity-100');
            }, 100);
        }

        function resetGame() {
            gameOverScreen.classList.remove('scale-100', 'opacity-100');
            gameOverScreen.classList.add('scale-90', 'opacity-0');
            
            setTimeout(() => {
                gameOverScreen.classList.add('hidden');
                init();
                gameState = 'START';
                mainMenu.style.opacity = '1';
                mainMenu.style.pointerEvents = 'auto';
                // Loop is already running, no need to call animate()
            }, 300);
        }

        // --- Input Handling ---

        function handleInput(e) {
            if (e.type === 'keydown' && e.code !== 'Space') return;
            if (e.type === 'keydown') e.preventDefault(); // Stop scrolling

            if (gameState === 'START') {
                startGame();
            } else if (gameState === 'PLAYING') {
                bird.jump();
            } else if (gameState === 'GAMEOVER') {
                 // Prevent accidental restart immediately after death
                 // handled by button usually, but spacebar is nice too
                 // Adding a small cooldown or just relying on button for safety
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleInput(e);
        });

        window.addEventListener('touchstart', (e) => {
            // Prevent default only if tapping on canvas, not buttons
            if(e.target.tagName !== 'BUTTON') {
                handleInput(e);
            }
        }, {passive: false});

        window.addEventListener('mousedown', (e) => {
            if(e.target.tagName !== 'BUTTON') {
                handleInput(e);
            }
        });

        startBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            startGame();
        });

        restartBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            resetGame();
        });

        // Start the loop
        init();
        animate();

    </script>
</body>
</html>
